#!/bin/bash

# Matthew Wyczalkowski <m.wyczalkowski@wustl.edu>
# https://dinglab.wustl.edu/

# TODO combine runLogger and logStash
# this also registers

read -r -d '' USAGE <<'EOF'
Register, query, and archive Cromwell runs 

Usage:
  bash runtidy [options] [ CASE1 [CASE2 ...]]

Required options:

Optional options
-h: print usage information
-d: dry run: print commands but do not run
-v: verbose
-1: stop after one case processed.
-x TASK: Execute given task.  Values: 'query' (default), 'register', 'stash', 'finalize'
-k CASES_FN: file with list of all cases, one per line, used when CASE1 not defined. Default: dat/cases.dat
-l LOGD: directory where runtime output (CASE.out, CASE.err, CASE.log ) written.  Default "./logs"
-T STASHD: root directory of archived logs.  Default "./logs"
-L RUNLOG: Run log path.  Default: "./logs/runlog.dat"
-y YAMLD: directory with YAML input files (named CASE.yaml).  Default "./yaml"
-Y: move (not copy) YAML files
-F: Force stashing even if run not in runlog.dat
-f STATUS: Force processing of runs of given status.  Require all cases to have same status
-c CROMWELL_QUERY: explicit path to cromwell query utility `cq`.  Default "cq" 
-m NOTE: A note added to run log file for each case

Runtidy performs the following task:
* `query`: Evaluate and print for each case
    - case, workflowId, run output log path
* `register`: write entry in run log
* `stash`: copy run output data to directory named after workflowID
* `finalize`: Run `register` and `stash` tasks, and also register with `runtidy`

A runlog file has the following columns
    * `CASE`
    * `WorkflowID`
    * `Status`
    * `StartTime`
    * `EndTime`
    * `Note` - optional, may indicate whether a restart, etc.
A line is added to runlog for every case with a known WorkflowID every time this utility is run; this allows for runs to change 
status over time, and multiple lines for same case and/or workflow ID is not an error.  By default, only runs with status of
Succeeded or Failed will logged.  -f flag will make all runs be logged.

Move run output files and copy YAML files to a directory named after WorkflowID

Registration of runs in runlog allows mapping of CASE to WorkflowID of past runs even when logs are stashed (i.e., logs/CASE.out is
no longer available).

If files do not exist print a warning but proceed, so that running this utility twice does not yield
an error

If this WorkflowID does not exist in runlog file exit with an error, since not having this entry will make it hard
to map CASE to WorkflowID in future.  Override this error with -F

By default, runs which do not have status Succeeded or Failed will yield a warning and will not be moved; this
can be overwritten with -f.

YAML files by default are copied while keeping the original, so that runs can be restarted more easily.
  Such files can instead be moved with -Y flag, so that ./yaml directory gets cleaned up

If CASE is - then read CASE from STDIN.  If CASE is not defined, read from CASES_FN file.

This script relies on `cq` to get WorkflowID and status associated with each case
EOF

source cromwell_utils.sh

SCRIPT=$(basename $0)
SCRIPT_PATH=$(dirname $0)

CROMWELL_QUERY="cq"
LOGD="./logs"
STASHD="./logs"
RUNLOG="./logs/runlog.dat"
YAMLD="./yaml"
CASES_FN="dat/cases.dat"
QUIET=1

while getopts ":hd1k:l:T:fFc:L:Yv" opt; do
  case $opt in
    h) 
      echo "$USAGE"
      exit 0
      ;;
    d)  # echo work command instead of evaluating it
      DRYRUN="d"
      ;;
    1) 
      JUSTONE=1
      ;;
    v) 
      QUIET=0
      ;;
    k) 
      CASES_FN="$OPTARG"
      ;;
    l) 
      LOGD="$OPTARG"
      ;;
    T) 
      STASHD="$OPTARG"
      ;;
    f)
      FORCE_STATUS=1    # force stashing regardless of status
      ;;
    F)
      FORCE_RUNLOG=1    # force stashing regardless of runlog
      ;;
    c) 
      CROMWELL_QUERY="$OPTARG"
      ;;
    L) 
      RUNLOG="$OPTARG"
      ;;
    Y) 
      YAML_MV=1
      ;;
    \?)
      >&2 echo "Invalid option: -$OPTARG" 
      >&2 echo "$USAGE"
      exit 1
      ;;
    :)
      >&2 echo "Option -$OPTARG requires an argument." 
      >&2 echo "$USAGE"
      exit 1
      ;;
  esac
done
shift $((OPTIND-1))

mkdir -p $LOGD
test_exit_status

# this allows us to get case names in one of three ways:
# 1: cq CASE1 CASE2 ...
# 2: cat cases.dat | cq -
# 3: read from CASES_FN file
# Note that if no cases defined, assume CASE='-'
if [ "$#" == 0 ]; then
    confirm $CASES_FN
    CASES=$(cat $CASES_FN)
elif [ "$1" == "-" ] ; then
    CASES=$(cat - )
else
    CASES="$@"
fi

# Core algorithm. For each case:
#  * Test if CASE.err, CASE.out, and CASE.yaml files exist.  
#    If any do not, test to see if stashed directory (based on WorkflowID) exists.
#    If it does not, print warning and continue to next case
#  * Obtain WorkflowID of case based on CASE.out.
#  * Obtain Status of WorkflowID based on call to `cq`
#    * if Status is not "Succeeded" print warning and continue to next case, unless FORCE_STATUS=1
#  * Check if STASHD/WorkflowID directory exists.  If it does, exit with an error
#  * Check if runlog has entry with WorkflowID.  If it does not, exit with an error, unless FORCE_RUNLOG=1
#  * Move LOGD/CASE.* and YAMLD/CASE.yaml to STASHD/WorkflowID
confirm $RUNLOG

for CASE in $CASES; do
    [[ $CASE = \#* ]] && continue
#    >&2 echo Processing case $CASE

    OUTFN="$LOGD/$CASE.out"
    ERRFN="$LOGD/$CASE.err"
    YAMLFN="$YAMLD/$CASE.yaml"
    WID=$( $CROMWELL_QUERY -V -q wid $CASE ) 

    if [ ! -f $OUTFN ] || [ ! -f $ERRFN ] || [ ! -f $YAMLFN ]; then
    # Log files missing.  See if they've already been stashed
        if [ -d $LOGD/$WID ]; then
            >&2 echo $CASE already stashed 
        else
            >&2 echo WARNING: $CASE: Log/yaml files does not exist, skipping this case 
        fi
        continue
    fi

    # WID may be unknown for various reasons, like error conditions.  Stashing requires that this
    # value be known; if it is not, print a complaint and go on
    if [ $WID == "Unknown" ]; then
        >&2 echo Warning: WorkflowID for $CASE is $WID.  Not stashing these logs, continuing
        continue
    fi

    STATUS=$( $CROMWELL_QUERY -V -q status $CASE ) 
    test_exit_status
    if [ $STATUS != "Succeeded" ] && [ $STATUS != "Failed" ]; then
        if [ "$FORCE_STATUS" ]; then
            >&2 echo NOTE: $CASE status is $STATUS.  Proceeding with stashing
        else
            >&2 echo WARNING: $CASE status is $STATUS.  Skipping this case
            continue
        fi
    fi

    if ! grep -F -q $WID $RUNLOG ; then
        if [ -z $FORCE_RUNLOG ]; then
            >&2 echo ERROR: $CASE \( $WID \) not found in $RUNLOG. Register run with \`runLogger.sh\` before stashing or override with -F.  Exiting.
            exit 1
        else 
            >&2 echo Warning: Case $CASE \( $WID \) not found in $RUNLOG.  Continuing
        fi
    fi

    OUTD="$STASHD/$WID"
    if [ -d $OUTD ]; then
        >&2 echo WARNING: Stash directory exists: $OUTD
        >&2 echo Skipping this case
        continue
    fi

    CMD="mkdir -p $OUTD"
    run_cmd "$CMD" "$DRYRUN" $QUIET

    CMD="mv $LOGD/$CASE.* $OUTD"
    run_cmd "$CMD" "$DRYRUN" $QUIET

    if [ "$YAML_MV" ]; then
        CMD="mv $YAMLD/$CASE.yaml $OUTD"
    else
        CMD="cp $YAMLD/$CASE.yaml $OUTD"
    fi
    run_cmd "$CMD" "$DRYRUN" $QUIET


    if [ $JUSTONE ]; then
        break
    fi

done

